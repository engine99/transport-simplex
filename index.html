<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Transport-simplex by engine99</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Transport-simplex</h1>
        <p>C++ implementation of the transportation simplex algorithm</p>

        <p class="view"><a href="https://github.com/engine99/transport-simplex">View the Project on GitHub <small>engine99/transport-simplex</small></a></p>


        <ul>
          <li><a href="https://github.com/engine99/transport-simplex/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/engine99/transport-simplex/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/engine99/transport-simplex">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>

<h3><center> C++ code for </center></h3>
<h2><center> The Transporation Problem </center></h2>
<h3>Synopsis</h3>
<p>
The transporation problem is the task of computing the minimum cost required to transport goods
from a set of Source nodes to a set of Sink nodes along a bipartite transportation network. To
formulate the problem, we must know the supply at each Source, the demand at each sink, and the unit
cost of transporting goods from each Source to each Sink.
</p>
<p>
If the cost of transporting good from each Source to each Sink is linear in the number of goods
transported, the problem can be solved using linear programming. The code contained in this site 
solves the transportation problem using the <b>transportation simplex algorithm</b> as described in Hillier
and Leiberman [1].
</p>
<p>
The Transportation Problem is used in network analysis, operations research, and in the Earth Mover's Distance, 
a metric for comparing distributions.
</p>

<h3>Code</h3>
<p>
The package contains only a header file. The additional file shows example usage.
</p>
<p>
Header file: transportSimplex.h<br>
Example code: main.cpp
</p>


<h3>Objective</h3>
<p>
The objective of publishing this code is to make a high-quality, high-speed algorithm available freely and
promote the use of the Earth Mover's Distance (EMD) in image processing [3].
</p>

<h3>Features</h3>
<ul>
<li> Streamlined code for very fast execution</li>
<li> Appropriate for large problems (&gt;1000 Sources and Sinks) </li>
<li> Concise (&lt;800 lines) </li>
<li> Portable </li>
<li> No preset limits on size of Source or Sink sets </li>
<li> Able to handle problems with different total supply or demand sums </li>
<li> Functions are templated to handle user-defined Source and Sink types </li>
<li> Initialization can be done using either Russel's or Vogel's approximation methods </li>
</ul>

<h3>Disclaimer</h3>
<p>
The interface and data structures used in this release were adapted from Yossi Rubner's emd.c [2].
</p>

<h3>Use</h3>
<p>
The main routine is: 
</p>
<p class="code">
template &lt;class TF&gt;<br>
double transportSimplex(TsSignature &lt;TF&gt; *signature1, TsSignature&lt;TF&gt; *signature2,<br> 
&nbsp;&nbsp;&nbsp;&nbsp;double (*grndDist)(TF *, TF *),	TsFlow *flowTable = NULL, int *flowSize = NULL);
</p>
<p>
The function returns the total transportation cost. <span class="code">Signature1</span> and 
<span class="code">Signature2</span> are the Source and Sink sets (the operation is commutative). Each signature
contains an array of features (the TF type) and an array of their respective positive non-zero supply or demand.
The signature type is defined as
</p>
<p class="code">
template &lt;class TF&gt;<br>
class TsSignature {<br>
public:<br>
&nbsp;&nbsp;&nbsp;&nbsp;	int n;									// Number of features in the signature <br>
&nbsp;&nbsp;&nbsp;&nbsp;	TF *features;							// Pointer to the features vector <br>
&nbsp;&nbsp;&nbsp;&nbsp;	double *weights;						// Pointer to the weights of the features <br>
&nbsp;&nbsp;&nbsp;&nbsp;	TsSignature(int nin, TF *fin, double * win):n(nin), features(fin), weights(win){};<br>
};<br>
</p>
<p>
grndDist is a pointer to a function which computes the distance between two features. The function take a pointer
to a source and a pointer to a sink as arguments and return a positive non-zero cost.
</p>
<p>
Finally, flowTable is an output parameter which can be set to an array that will be filled with the final flow amounts.
The array must be of size <span class="code"> Signature1-&gt;n + Signature2-&gt;n - 1 </span>. FlowSize is a pointer to an
integer which indicates the number of functional entries in Flow, because all spaces are not necessarily used. Flow 
and FlowSize can be set to NULL (or omitted) if this information is not important. The flow type is defined as:
</p>
<p class="code">
typedef struct TsFlow {<br>
&nbsp;&nbsp;&nbsp;&nbsp;	int from;								// Feature number in signature 1 <br>
&nbsp;&nbsp;&nbsp;&nbsp;	int to;									// Feature number in signature 2 <br>
&nbsp;&nbsp;&nbsp;&nbsp;	double amount;							// Amount of flow <br>
} TsFlow; <br>
</p>
<p>
Here, <span class="code">from</span> indexes the feature in signature 1, <span class="code">to</span> indexes 
the feature in signature 2, and <span class="code">amount</span> specifies the amount of flow between the two
features.
</p>
<p>
The data types and functions of this package are declared under the namespace <span class="code">dt_simplex</span>.
However since there are very few names and they are named distinctly, it should be safe to include the namespace
in user code as follows: <br>
<span class="code">using namespace dt_simplex;</span>
</p>
<p>
<span class="code">transportSimplex</span> throws two errors, which are of type <span class="code">TsError</span>. If the error 
is <span class="code">TsErrBadAlloc</span>, there is not enough heap memory to run the algorithm. If the error is
<span class="code">TsErrBadInput</span>, there is either a negative signature weight or a negative cost was found.
</p>
<p>
See the example file, main.cpp, for example usage.
</p>
<h3>Notes</h3>
<p>
<b>Initialization</b>
The basic feasible solution can be computed using either Russel's or Vogel's approximation methods [1]. Both routines were included in
order that they could be compared directly. In most cases Russel's method yeilds a better initial solution, though it takes longer than
Vogel's method (finding the next entering variable in Russel's method is in O(n1 * n2), and in O(n1 + n2) for Vogel's method). However,
Russel's method normally has a lesser total running time because less pivots are required to reach the optimum for all but small problem
sizes (n1 + n2 =~ 20).

Russel's method is used by default, but can be easily swapped at line ~200 in transportSimplex.h.

</p>
<p>
<b>Running Time</b> - The resources required to run this program depend on the number of sources (n1) and sinks (n2). The relative performance of the algorithm (using
both Vogel's and Russel's Approximations) as a function of problem size is illustrated in the charts below. These tests use identical
sized source and sink signatures which were derived from digital image colour histograms. The top left chart shows the asymptotical
speed advantage of Vogel's initialization. However, the better quality of Russel's initialization results in less pivots (upper right)
and less total time (lower left) required to reach the optimum. 
</p>
<p>
The lower right chart shows the performance of transportSimplex.h compared to emd.c [2], a transport simplex implementation which is
often used to compute the Earth Mover's Distance by image processing researchers. Problems having more than 350 sources and sinks
would cause a stack overflow error in emd.c
</p>
<p>
<img src="./transportSimplexCharts.JPG" width="739" height="561" border="0" alt="">
</p>
<p>
<b>Memory Requirements</b> - Memory for this program is allocated dynamically so that n1 and n2 do not need to be known at compile time. The largest data item is the cost matrix <span class="code">_tsC</span>, which stores the precomputed costs between each source and sink and has size n1 * n2. 
</p>
<h3>References</h3>
<p>
[1] F. S. Hillier and Gerald J. Leiberman, <i>Introduction to Operations Research, 5ed.</i> McGraw-Hill, 1990.
</p>
<p>
[2] Y. Rubner, "Code for the Earth Mover's Distance (EMD)," 1998, http://vision.stanford.edu/~rubner/emd/.
</p>
<p>
[3] Y. Rubner and C. Tomasi. Perceptual Metrics for Image Database Navigation.
Kluwer Academic Publishers, Boston, December 2000.
</p>
<p>
</p><hr>

      <footer>
        <p>This project is maintained by <a href="https://github.com/engine99">engine99</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>